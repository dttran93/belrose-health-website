import { Timestamp } from 'firebase/firestore';
import { ReactNode } from 'react';

// ==================== USER & AUTHENTICATION ====================

export interface User {
  uid: string;
  email: string | null;
  displayName: string | null;
  firstName: string | null;
  lastName: string | null;
  photoURL?: string | null;

  encryption: {
    enabled: boolean;
    encryptedMasterKey: string;
    masterKeyIV: string;
    masterKeySalt: string;
    recoveryKeyHash: string; // for recovery key verification
    setupAt: string;
    lastUnlockedAt?: string; // track usage

    // RSA Sharing Keys (used for sharing and unwrapping shared file keys)
    encryptedPrivateKey: string; // The encrypted RSA Private Key (encrypted by Master Key)
    encryptedPrivateKeyIV: string; // The IV for the encrypted RSA Private Key
    publicKey: string; // The RSA Public Key
  };
}

export interface BelroseUserProfile extends User {
  createdAt: any;
  updatedAt: any;
  wallet: UserWallet;
  emailVerified: boolean;
  emailVerifiedAt?: any;
  identityVerified: boolean;
  identityVerifiedAt?: any;

  onChainIdentity?: {
    userIdHash: string; // The keccak256 hash of the UID
    status: 'Inactive' | 'Active' | 'Verified';
    statusUpdatedAt?: any;
    statusTxHash?: string;

    // The collection of all linked wallets to this identity on the contract
    linkedWallets: LinkedWalletRecord[];
  };

  //Other Info
  affiliations?: [string] | [];
}

// ==================== WALLET TYPES ====================
export type WalletOrigin = 'generated' | 'metamask' | 'walletconnect' | 'hardware';

export interface UserWallet {
  address: string;
  origin: WalletOrigin;
  smartAccountAddress?: string; //Smart account used for account abstraction and gasless payments

  // Only present for generated wallets (Belrose stores encrypted keys)
  encryptedPrivateKey?: string;
  encryptedPrivateKeyIV?: string;
  keyAuthTag?: string;
  keySalt?: string;
  encryptedMnemonic?: string;
  mnemonicIv?: string;
  mnemonicAuthTag?: string;
  mnemonicSalt?: string;
}

/**
 * Represents a single wallet address linked to a user's on-chain identity
 */
export interface LinkedWalletRecord {
  address: string;
  type: 'eoa' | 'smart-account';
  txHash: string;
  blockNumber: number;
  linkedAt: any; // Timestamp
  isWalletActive: boolean; // Reflects contract's isWalletActive status
}

// Authentication context data structure
export interface AuthContextData {
  user: BelroseUserProfile | null;
  loading: boolean;
  signOut: () => Promise<void>;
  isAuthenticated: boolean;
  refreshUser: () => {};
}

// Props for components that need auth context
export interface AuthProviderProps {
  children: ReactNode;
}

export interface ProtectedRouteProps {
  children: ReactNode;
}

// Location state for navigation
export interface LocationState {
  from: {
    pathname: string;
  };
}

// ==================== HEALTH RECORDS FILE ====================

//Base Belrose Fields generated by createBelroseFields Coud function
export interface BelroseFields {
  visitType: string; // e.g., "Follow-up Appointment", "Lab Results", "Imaging Study"
  title: string; // Short descriptive title (e.g., "Cardiology Follow-up")
  summary: string; // Tweet-length summary, main information a future reader would need to know
  completedDate: string; // ISO date string - the main date for this record
  provider: string; // Primary provider name
  institution: string; // Healthcare institution/facility
  patient: string; // Patient Name
  detailedNarrative?: string; //detailed information on the medical interaction. derived from FHIR, but human readable
}

export interface RoleInitialization {
  blockchainInitialized: boolean;
  blockchainInitializedAt: Timestamp;
  blockchainInitTxHash: string;
  blockchainInitBlockNumber: number;
  syncedFromChain: boolean; //For when an intialization had to be self-healed. Indicates there was an issue with updating firebase previously for future debugging/auditing
}

export interface RecordInitialization {
  blockchainTxId: string; //Transaction ID on the blockchain
  providerSignature?: string; //Digital signature (for provider records)
  signerId?: string; //ID of who signed it
  blockchainNetwork: string; //blockchain network, e.g. ethereum, solana
  timestamp: number; //when it was recorded
  isVerified: boolean; //whether blockchain verification passed. May change this to a credit system of sorts in the future
}

export type AIProcessingStatus =
  | 'pending' // AI processing not yet started
  | 'processing' // AI is currently processing
  | 'completed' // AI processing finished successfully
  | 'failed' // AI processing failed
  | 'not_needed'; // This record type doesn't need AI processing

export type FileStatus =
  | 'open' //waiting to upload
  | 'pending' // File uploaded, waiting to process
  | 'processing' // Currently being processed
  | 'uploading' // Currently uploading, use for making sure there aren't multiple uploads
  | 'completed' // Successfully processed
  | 'error'; // Failed with error

export type SourceType = 'Plain Text Submission' | 'Manual FHIR JSON Submission' | 'File Upload';

//Processing Stages good for the progress chips in the Add Record process
export type ProcessingStages =
  | 'Starting processing...'
  | 'Extracting text...'
  | 'Text extraction completed'
  | 'Converting to FHIR...'
  | 'FHIR conversion completed'
  | 'Completing...'
  | 'AI processing...'
  | 'AI analyzing content...'
  | 'Encrypting record data...'
  | 'Record encrypted'
  | 'Generating record hash...'
  | undefined;

export interface VirtualFileInput {
  fileName?: string;
  sourceType?: SourceType;
  extractedText?: string;
  fhirData?: any;
  wordCount?: number;
  [key: string]: any;
}

export interface FileObject {
  // === CORE IDENTIFICATION, (EXCLUDES FILE NAME, IN ENCRYPTED HEALTH DATA SECTION BELOW) ===
  id: string; //fileId. Generated in useFileManager via createFileObject() or addVirtualFile(). file_${Date.now()}_${Math.random().toString(36).substr(2, 9)}
  firestoreId?: string; //Id for firestore set after upload

  // === FILE PROPERTIES (EXCLUDES FILE, IN ENCRYPTED HEALTH DATA SECTION BELOW)===
  fileSize: number; //file size. Set in createFileObject in useFileManager.ts. file.size for real files
  fileType: string; //file type. Set in createFileObject in useFileManager.ts. file.type for real files or application/fhir+json for virtual - NEVER undefined
  wordCount?: number; //calculated during text extraction

  // === OWNERSHIP AND PERMISSIONS ===
  uploadedBy?: string; // User ID of who created/uploaded the record (for audit trail)
  owners?: string[]; // Array of user IDs with ultimate ownership access to record (read, update, delete, share)
  administrators: string[]; //Array of userIDs with administrative access to records, can't remove others
  viewers?: string[]; // Array of user IDs with view access to record
  subjects?: string[]; //The subject of this record. Made it an array for edge cases where there are multiple subjects (couples therapy, mother/newborn, family history, genetic testing)
  pendingSubjectRequests?: {
    userId: string;
    requestedBy: string;
    requestedAt: Timestamp;
    status: 'pending' | 'accepted' | 'rejected';
  }[]; //If you set a subject in a record as someone else, that person must accept it for it to show up in their record.

  // === PROCESSING STATUS ===
  status: FileStatus; //Processing property. Initially set as pending. Then pending/processing... see below
  error?: string; //Failed processing
  aiProcessingStatus?: AIProcessingStatus; //For Belrose Fields
  processingStage?: ProcessingStages;
  uploadInProgress?: boolean; // for managing upload process

  // === VERIFICATION AND SECURITY ===
  originalFileHash?: string | null; //hash of the original file that was uploaded
  recordHash?: string | null; //hash of the record content
  previousRecordHash?: string[] | null; //to establish chain of records in case they are edited
  blockchainRoleInitialization?: RoleInitialization;

  // === METADATA ===
  sourceType?: SourceType;
  isVirtual?: boolean; //for virtual files
  downloadURL?: string;
  storagePath?: string;
  versionNumber?: string;

  // === TIMESTAMPS ===
  uploadedAt?: Timestamp;
  createdAt?: Timestamp;
  lastModified?: Timestamp; //Filetracking for UI state management.

  // PLAIN TEXT PERSONAL HEALTH DATA, MUST BE ENCRYPTED
  fileName: string; //file name or custom name for virtual files. set by createFileObject() in useFileManager.ts
  file?: File; //actual file object from file input. Real life upload not virtual. Generated in createFileObject in useFileManager.ts
  extractedText?: string | null; //text extracted from image/pdf
  originalText?: string | null; //text typed into app by user
  contextText?: string | null; //context provided along with either the file upload or fhir upload
  fhirData?: any;
  belroseFields?: BelroseFields; //AI enriched fields for easy labeling within the Belrose App
  customData?: any; //for non-medical data that may come in different formats, but not be particularly suited to FHIR format

  // Individual encrypted fields (as stored in Firestore)
  encryptedFileName?: { encrypted: string; iv: string };
  encryptedExtractedText?: { encrypted: string; iv: string };
  encryptedOriginalText?: { encrypted: string; iv: string };
  encryptedContextText?: { encrypted: string; iv: string };
  encryptedFhirData?: { encrypted: string; iv: string };
  encryptedBelroseFields?: { encrypted: string; iv: string };
  encryptedCustomData?: { encrypted: string; iv: string };

  // Encryption fields at ROOT level (as stored in Firestore)
  isEncrypted?: boolean;
  encryptedFileIV?: string; // IV for the file stored in Firebase Storage

  //Used during processing, ArrayBuffers are in memory. But roo-level encrypted Fiels are for retrieval in Firestore
  encryptedData?: {
    encryptedKey: string; // Single key for all encrypted data (Base64)

    // Encrypted fileName (always exists - contains PII!)
    fileName: {
      encrypted: ArrayBuffer; // Only exists during upload process
      iv: string; // Base64
    };

    // Encrypted file (original upload) - stored in memory during processing
    file?: {
      encrypted: ArrayBuffer; // Only exists during upload process
      iv: string; // Base64
    };

    // Encrypted extracted text
    extractedText?: {
      encrypted: ArrayBuffer; // Only exists during upload process
      iv: string; // Base64
    };

    // Encrypted original text (if exists)
    originalText?: {
      encrypted: ArrayBuffer; // Only exists during upload process
      iv: string; // Base64
    };

    // Encrypted context text (if exists)
    contextText?: {
      encrypted: ArrayBuffer; // Only exists during upload process
      iv: string; // Base64
    };

    // Encrypted FHIR data (if exists)
    fhirData?: {
      encrypted: ArrayBuffer; // Only exists during upload process
      iv: string; // Base64
    };

    // Encrypted belrose fields (if exists)
    belroseFields?: {
      encrypted: ArrayBuffer; // Only exists during upload process
      iv: string; // Base64
    };

    // Encrypted custom data (if exists)
    customData?: {
      encrypted: ArrayBuffer; // Only exists during upload process
      iv: string; // Base64
    };
  };
}
