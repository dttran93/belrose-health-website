rules_version = '2';
service cloud.firestore {

	//Function to restrict writes to the Admin SDK
  function isServerWrite() {
  	//The Admin SDK request will have auth but NO token payload database
    return request.auth != null &&
    	!('token' in request.auth);
  }
  
    match /databases/{database}/documents {
    
     // Helper: Check if user has any role on the record
  function hasRoleOnRecord(recordId) {
    let record = get(/databases/$(database)/documents/records/$(recordId));
    return record != null && (
      request.auth.uid in record.data.owners ||
      request.auth.uid in record.data.administrators ||
      request.auth.uid in record.data.viewers ||
      request.auth.uid in record.data.subjects
    );
  }
    
    // === USER PROFILES ===
    match /users/{userId} {
      allow read, write: if request.auth != null && request.auth.uid == userId;
      
      // Any authenticated user can read user profiles (needed for sharing)
      allow read: if request.auth != null;
      
      // === NOTIFICATIONS SUBCOLLECTION ===
      match /notifications/{notificationId} {
      	
        // READ/LIST: A user can only read their own notifications
        allow read: if request.auth != null && request.auth.uid == userId;
        
        //CREATE: Notifications are ONLY created by the server (Cloud Functions)
        // The read field must be false and createdAt must be set
        allow create: if request.auth.uid == userId &&
        								request.resource.data.read == false &&
                        request.resource.data.createdAt is timestamp
                        && isServerWrite(); // only server can write
        
        //UPDATE: Users can ONLY mark a notification as read (i.e. set 'read' to true)
        allow update: if request.auth != null &&
        								request.auth.uid == userId &&
                        request.resource.data.diff(resource.data).affectedKeys().hasOnly(['read']) &&
                        request.resource.data.read == true;
        
        //DELETION: Deletion is restricted to the server (for cleanup jobs)
        // Client-side deletes forbidden.
        allow delete: if request.auth.uid == userId && isServerWrite();
      }
    }
    
    // === GLOBAL RECORDS COLLECTION ===
    match /records/{recordId} { 
    
      // Helper: Check if update is ONLY adding self to requests array
function isOnlyAddingSelfAsSubject() {
  let affectedKeys = request.resource.data.diff(resource.data).affectedKeys();
  
  // 1. Ensure only 'subjects' and 'lastModified' are being changed
  let isRightKeys = affectedKeys.hasOnly(['subjects', 'lastModified']);
  
  // 2. Ensure the subjects array is actually growing by exactly 1
  let subjectsBefore = resource.data.get('subjects', []);
  let subjectsAfter = request.resource.data.subjects;
  let arrayGrewCorrectly = subjectsAfter.size() == subjectsBefore.size() + 1;
  
  // 3. Ensure the person being added is the one signed in
  let addedSelf = request.auth.uid in subjectsAfter && !(request.auth.uid in subjectsBefore);

  return isRightKeys && arrayGrewCorrectly && addedSelf;
}

//Helper: Check if viewer is removing themselves as a subject
function isSelfRejectionFlow() {
    let affectedKeys = request.resource.data.diff(resource.data).affectedKeys();
    
    // Check if they are modifying subjects and subjectRejections
    let isRightKeys = affectedKeys.hasOnly(['subjects', 'viewers', 'lastModified']);
    
    // Check they are removing themselves from subjects
    let removedSelf = !(request.auth.uid in request.resource.data.subjects) && 
                      (request.auth.uid in resource.data.subjects);
  	let removingSelfViewer = (request.auth.uid in resource.data.get('viewers', [])) && 
                           !(request.auth.uid in request.resource.data.get('viewers', []));
                      
    return isRightKeys && removedSelf;
  }

      
      // Helper: Combined management check to ensure the record isn't left without an admin/owner
  function willHaveManagement() {
    let hasOwners = "owners" in request.resource.data && request.resource.data.owners.size() > 0;
    let hasAdmins = "administrators" in request.resource.data && request.resource.data.administrators.size() > 0;
    return hasOwners || hasAdmins;
  }
  
  //Helper: Check if owners array is being modified
  function isModifyingOwners(){
  	return request.resource.data.owners != resource.data.owners;
  }

      // READ: User can read if they:
      // 1. Uploaded the record themselves
      // 2. Are in the owners array
      // 3. Are in the administrators array
      // 4. Are in the viewers array
      // 5. Are the subject of the record
      // 6. Have a PENDING consent request - for review flow
      allow read: if request.auth != null && (
        resource.data.uploadedBy == request.auth.uid ||
        request.auth.uid in resource.data.owners ||
        request.auth.uid in resource.data.administrators ||
        request.auth.uid in resource.data.viewers ||
        request.auth.uid in resource.data.subjects
      );

      // CREATE: User must be authenticated and be in the administrators array being created
      allow create: if request.auth != null && willHaveManagement();
     
      // UPDATE: Admins/owners can update, OR user with consent can add self as subject
      allow update: if request.auth != null && (
        // BRANCH 1: Existing admin/owner flow
        (
          (request.auth.uid in resource.data.administrators ||
           request.auth.uid in resource.data.owners) &&
          // MANDATORY: The resulting update MUST leave at least one owner or one administrator
          willHaveManagement() &&
          // Owners array modification rules:
          // - If not modifying owners array, allow
          // - If owners array is empty, administrators can add owners
          // - If owners array has people, only existing owners can modify it
          (!isModifyingOwners() || 
           (resource.data.owners.size() == 0 && request.auth.uid in resource.data.administrators) ||
           (resource.data.owners.size() > 0 && request.auth.uid in resource.data.owners))
        )
        ||
        // BRANCH 2: Subject consent flow - user adding self to subjects array
        // User must already have access (granted when consent request was created)
        // and can ONLY add themselves to subjects
        (
          (request.auth.uid in resource.data.viewers ||
           request.auth.uid in resource.data.administrators ||
           request.auth.uid in resource.data.owners) &&
          isOnlyAddingSelfAsSubject()
        )
        ||
        //BRANCH 3: Subject rejection flow (Removing self)
        (
      request.auth.uid in resource.data.subjects &&
      isSelfRejectionFlow()
    )
      );

      // DELETE: 
      // - If there's an owner, ONLY they can delete
      // - If there's NO owner, administrators can delete
      allow delete: if request.auth != null && (
        request.auth.uid in resource.data.owners ||
        (resource.data.owners.size() == 0 && request.auth.uid in resource.data.administrators)
      );
    }
       
    // === PENDING PERMISSIONS (Retry Queue) ===
    match /pendingPermissions/{permissionHash} {
      // Users can create pending permissions when Firestore writes fail after blockchain succeeds
      allow create: if request.auth != null &&
        request.resource.data.recordId != null &&
        request.resource.data.receiverId != null;

      // Allow system/admin reads for background processing
      allow read: if request.auth != null;

      // Allow updates for retry processing
      allow update: if request.auth != null;

      // Allow deletion after successful retry
      allow delete: if request.auth != null;
    }
    
    // === WRAPPED KEYS ===
    match /wrappedKeys/{wrappedKeyId} {
      // Read: Anyone can read that a key exists
      allow read: if request.auth != null
      
      // Create: admins/owners can create wrapped keys for their records
      allow create: if request.auth != null &&
        isAdminOrOwnerOfRecord(request.resource.data.recordId);
      
      // Update: admins/owners can update (for reactivation/revocation)
      allow update: if request.auth != null &&
        isAdminOrOwnerOfRecord(resource.data.recordId);
      
      // No hard deletes
      allow delete: if false;
    }
    
    function isAdminOrOwnerOfRecord(recordId) {
      let record = get(/databases/$(database)/documents/records/$(recordId)).data;
      return record != null && (
        request.auth.uid in record.owners || 
        request.auth.uid in record.administrators
      );
    }
    
    // === RECORD VERSIONS (GLOBAL - NEW STRUCTURE) ===
    match /recordVersions/{versionId} {
      // Helper function to check if user has access to the parent record
      function hasVersionAccess() {
        let recordId = resource.data.recordId;
        let record = get(/databases/$(database)/documents/records/$(recordId));
        return request.auth.uid in record.data.owners ||
               request.auth.uid in record.data.administrators;
      }

      function hasVersionAccessForCreate() {
        let recordId = request.resource.data.recordId;
        let record = get(/databases/$(database)/documents/records/$(recordId));
        return request.auth.uid in record.data.owners ||
               request.auth.uid in record.data.administrators;
      }

      // Only owners (subjects) can delete versions
      function canDeleteVersion() {
        let recordId = resource.data.recordId;
        let record = get(/databases/$(database)/documents/records/$(recordId));
        
        // Only the record owner (subject) can delete
        return request.auth.uid in record.data.owners;
      }

      // Users can read versions if they have access to the parent record
      allow read: if request.auth != null && hasVersionAccess();

      // Users can create versions if they have access to the parent record
      allow create: if request.auth != null && 
        hasVersionAccessForCreate() &&
        request.resource.data.editedBy == request.auth.uid;

      // No updates allowed (versions are immutable)
      allow update: if false;

      // Only record owners can delete
      allow delete: if request.auth != null && canDeleteVersion();
    }
    
    // === USER ENCRYPTION KEYS ===
    match /userEncryptionKeys/{userId} {
      allow read, write: if request.auth != null && request.auth.uid == userId;
    }
    
    // === SUBJECT CONSENT REQUESTS ===
    match /subjectConsentRequests/{requestId} {
      // Helper: Check if user is admin/owner of the associated record
      function canManageRecord() {
        let record = get(/databases/$(database)/documents/records/$(resource.data.recordId));
        return request.auth.uid in record.data.owners ||
               request.auth.uid in record.data.administrators;
      }

      function canManageRecordForCreate() {
        let record = get(/databases/$(database)/documents/records/$(request.resource.data.recordId));
        return request.auth.uid in record.data.owners ||
               request.auth.uid in record.data.administrators;
      }

      // READ: User can read if they:
      // 1. Are the target user (receiving the request)
      // 2. Requested it themselves
      // 3. Are an admin/owner of the record
      allow read: if request.auth != null && (
      !exists(/databases/$(database)/documents/subjectConsentRequests/$(requestId)) ||
        resource.data.subjectId == request.auth.uid ||
        resource.data.requestedBy == request.auth.uid ||
        (request.auth.uid in get(/databases/$(database)/documents/records/$(resource.data.recordId)).data.owners ||
         request.auth.uid in get(/databases/$(database)/documents/records/$(resource.data.recordId)).data.administrators)
      );

      // CREATE: Must be authenticated AND:
      // 1. Be an admin/owner of the record
      // 2. Set themselves as requestedBy
      // 3. Include required fields
      // 4. Status must be 'pending'
      allow create: if request.auth != null &&
        canManageRecordForCreate() &&
        request.resource.data.requestedBy == request.auth.uid &&
        request.resource.data.status == 'pending' &&
        request.resource.data.recordId != null &&
        request.resource.data.subjectId != null &&
        request.resource.data.createdAt is timestamp &&
        (!('grantedAccessOnSubjectRequest' in request.resource.data.keys()) || 
         request.resource.data.grantedAccessOnSubjectRequest is bool);

      // UPDATE: Two branches:
      // 1. Subject can accept/reject
      // 2. Requester can update grantedAccessOnSubjectRequest
      allow update: if request.auth != null && (
        // BRANCH 1: Subject accepting/rejecting
        (
          resource.data.subjectId == request.auth.uid &&
          request.resource.data.status in ['accepted', 'rejected'] &&
          request.resource.data.diff(resource.data).affectedKeys().hasOnly(['status', 'respondedAt', 'rejection']) &&
          (!('respondedAt' in request.resource.data.diff(resource.data).affectedKeys()) || 
           request.resource.data.respondedAt is timestamp)
        ) 
        ||
        // BRANCH 2: Requester updating grantedAccessOnSubjectRequest
        (
          resource.data.requestedBy == request.auth.uid &&
          request.resource.data.diff(resource.data).affectedKeys().hasOnly(['grantedAccessOnSubjectRequest', 'rejection','lastModified'])
        )
      );

      // DELETE: Only the requester or record admins/owners can delete
      allow delete: if request.auth != null && (
        resource.data.requestedBy == request.auth.uid ||
        canManageRecord()
      );
    }
    
    // === BLOCKCHAIN SYNC RETRY QUEUE ===
    match /blockchainSyncQueue/{queueId} {
      // Allow users to log their own sync failures
      // We validate that they are only setting the status to 'pending'
      allow create: if request.auth != null &&
        request.resource.data.userId == request.auth.uid &&
        request.resource.data.status == 'pending' &&
        request.resource.data.retryCount == 0;

      // Only allow the user who logged it or an admin/server to read/update
      allow read, update: if request.auth != null && 
        (resource.data.userId == request.auth.uid || isServerWrite());
      
      // Deletion usually handled by server cleanup
      allow delete: if isServerWrite();
    }
    
    // === VERIFICATIONS ===
match /verifications/{verificationId} {
  
	// READ: Allow if user is verifier OR has role on the associated record
  // Note: For queries by recordId, the get() call happens per-document
  allow read: if request.auth != null && (
  !exists(/databases/$(database)/documents/verifications/$(verificationId)) ||
  // User is the verifier (can always read their own)
   resource.data.verifierId == request.auth.uid ||
  // User has a role on the record this verification belongs to
     hasRoleOnRecord(resource.data.recordId)
	);

  // CREATE: 
  // - User must have a role on the record
  // - User must be the verifier
  // - Document ID must match expected format (enforces uniqueness)
  // - Required fields validated
  allow create: if request.auth != null &&
    hasRoleOnRecord(request.resource.data.recordId) &&
    request.resource.data.verifierId == request.auth.uid &&
    // Enforce document ID format: {recordHash}_{verifierId}
    verificationId == request.resource.data.recordHash + '_' + request.auth.uid &&
    // Validate required fields
    request.resource.data.isActive == true &&
    request.resource.data.level in [1, 2, 3] &&
    request.resource.data.chainStatus == 'pending' &&
    request.resource.data.createdAt is timestamp;

  // Only the original verifier can modify their verification
  allow update: if request.auth != null &&
    resource.data.verifierId == request.auth.uid &&
    // Immutable fields - cannot be changed
    request.resource.data.verifierId == resource.data.verifierId &&
    request.resource.data.recordId == resource.data.recordId &&
    request.resource.data.recordHash == resource.data.recordHash &&
    request.resource.data.createdAt == resource.data.createdAt;

  // DELETE: Not allowed - use isActive flag instead
  allow delete: if false;
}

// === DISPUTES ===
match /disputes/{disputeId} {
  
  // READ: Allow if user is disputer OR has role on the associated record
  allow read: if request.auth != null && (
    !exists(/databases/$(database)/documents/disputes/$(disputeId)) ||
    resource.data.disputerId == request.auth.uid ||
    hasRoleOnRecord(resource.data.recordId)
  );

  // CREATE: 
  // - User must have a role on the record
  // - User must be the disputer
  // - Document ID must match expected format (enforces uniqueness)
  // - Required fields validated
  allow create: if request.auth != null &&
    hasRoleOnRecord(request.resource.data.recordId) &&
    request.resource.data.disputerId == request.auth.uid &&
    // Enforce document ID format: {recordHash}_{disputerId}
    disputeId == request.resource.data.recordHash + '_' + request.auth.uid &&
    // Validate required fields
    request.resource.data.isActive == true &&
    request.resource.data.severity in [1, 2, 3] &&
    request.resource.data.culpability in [0, 1, 2, 3, 4, 5] &&
    request.resource.data.chainStatus == 'pending' &&
    request.resource.data.createdAt is timestamp;

  // Only the original disputer can modify their dispute
  allow update: if request.auth != null &&
    resource.data.disputerId == request.auth.uid &&
    // Immutable fields - cannot be changed
    request.resource.data.disputerId == resource.data.disputerId &&
    request.resource.data.recordId == resource.data.recordId &&
    request.resource.data.recordHash == resource.data.recordHash &&
    request.resource.data.createdAt == resource.data.createdAt &&
    // Notes hash is immutable (it's on-chain)
    request.resource.data.notesHash == resource.data.notesHash &&
    request.resource.data.encryptedNotes == resource.data.encryptedNotes;

  // DELETE: Not allowed - use isActive flag instead
  allow delete: if false;
}

// === DISPUTE REACTIONS ===
match /disputeReactions/{reactionId} {
  
  // READ: Allow if user is reactor OR has role on the record
  allow read: if request.auth != null && (
  !exists(/databases/$(database)/documents/disputeReactions/$(reactionId)) ||
    resource.data.reactorId == request.auth.uid ||
    hasRoleOnRecord(resource.data.recordId)
  );

  // CREATE: User must be the reactor
  allow create: if request.auth != null &&
    request.resource.data.reactorId == request.auth.uid &&
    request.resource.data.isActive == true &&
    request.resource.data.chainStatus == 'pending' &&
    request.resource.data.createdAt is timestamp;

  // Only the original reactor can modify their reaction
  allow update: if request.auth != null &&
    resource.data.reactorId == request.auth.uid &&
    // Immutable fields
    request.resource.data.reactorId == resource.data.reactorId &&
    request.resource.data.recordHash == resource.data.recordHash &&
    request.resource.data.disputerId == resource.data.disputerId &&
    request.resource.data.createdAt == resource.data.createdAt;

  // DELETE: Not allowed - use isActive flag instead
  allow delete: if false;
}
    
    // === AUDIT LOGS ===
    match /audit/{auditId} {
      allow write: if request.auth != null;
      allow read: if false;
    }
  }
}