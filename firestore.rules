rules_version = '2';
service cloud.firestore {

  // ============================================
  // GLOBAL HELPER FUNCTIONS
  // ============================================

  // Restrict writes to the Admin SDK only
  // The Admin SDK request will have auth but NO token payload
  function isServerWrite() {
    return request.auth != null && !('token' in request.auth);
  }
  
  match /databases/{database}/documents {
    
    // ============================================
    // DATABASE-SCOPED HELPER FUNCTIONS
    // ============================================

    // Check if user has any role on a record
    function hasRoleOnRecord(recordId) {
      let record = get(/databases/$(database)/documents/records/$(recordId));
      return record != null && (
        record.data.uploadedBy == request.auth.uid ||
        request.auth.uid in record.data.owners ||
        request.auth.uid in record.data.administrators ||
        request.auth.uid in record.data.viewers ||
        request.auth.uid in record.data.subjects
      );
    }
      
    // Check if user is admin or owner of a record
    function isAdminOrOwnerOfRecord(recordId) {
      let record = get(/databases/$(database)/documents/records/$(recordId)).data;
      return record != null && (
        request.auth.uid in record.owners ||
        request.auth.uid in record.administrators
      );
    }

    // Ensure the record won't be left without management after update
    function willHaveManagement() {
      let hasOwners = "owners" in request.resource.data && request.resource.data.owners.size() > 0;
      let hasAdmins = "administrators" in request.resource.data && request.resource.data.administrators.size() > 0;
      return hasOwners || hasAdmins;
    }

    // Check if owners array is being modified
    function isModifyingOwners() {
      return request.resource.data.owners != resource.data.owners;
    }

    // Check if update is ONLY adding self to subjects array
    function isOnlyAddingSelfAsSubject() {
      let affectedKeys = request.resource.data.diff(resource.data).affectedKeys();
      let isRightKeys = affectedKeys.hasOnly(['subjects', 'lastModified']);
      let subjectsBefore = resource.data.get('subjects', []);
      let subjectsAfter = request.resource.data.subjects;
      let arrayGrewCorrectly = subjectsAfter.size() == subjectsBefore.size() + 1;
      let addedSelf = request.auth.uid in subjectsAfter && !(request.auth.uid in subjectsBefore);
      return isRightKeys && arrayGrewCorrectly && addedSelf;
    }

    // Check if user is removing themselves as a subject
    function isSelfRejectionFlow() {
      let affectedKeys = request.resource.data.diff(resource.data).affectedKeys();
      let isRightKeys = affectedKeys.hasOnly(['subjects', 'viewers', 'lastModified']);
      let removedSelf = !(request.auth.uid in request.resource.data.subjects) &&
                        (request.auth.uid in resource.data.subjects);
      return isRightKeys && removedSelf;
    }

    // ============================================
    // USER PROFILES/NOTIFICATIONS/CHATS
    // ============================================

    match /users/{userId} {
      // Owner can read/write their own profile
      allow read, write: if request.auth != null && request.auth.uid == userId;
      
      // Any authenticated user can read profiles (needed for sharing)
      allow read: if request.auth != null;
      
      // --- NOTIFICATIONS SUBCOLLECTION ---
      match /notifications/{notificationId} {
        // Users can only read their own notifications
        allow read: if request.auth != null && request.auth.uid == userId;
        
        // Notifications are ONLY created by the server (Cloud Functions)
        allow create: if request.auth.uid == userId &&
        	request.resource.data.read == false &&
          request.resource.data.createdAt is timestamp &&
          isServerWrite();
        
        // Users can ONLY mark a notification as read
        allow update: if request.auth != null &&
        								request.auth.uid == userId &&
                        request.resource.data.diff(resource.data).affectedKeys().hasOnly(['read']) &&
                        request.resource.data.read == true;
        
        // Deletion is restricted to the server (for cleanup jobs)
        allow delete: if request.auth.uid == userId && isServerWrite();
      }

      // -- CHATS COLLECTION ---
      match /chats/{chatId} {
        // Helper: Check if user owns this chat
        function isOwner() {
          return request.auth != null && request.auth.uid == userId;
        }

        // READ: Only the chat owner can read their chats
        allow read: if isOwner();

        // CREATE: User can create chats in their own collection
        // Encrypted fields (title, titleIv) stored directly in document
        allow create: if isOwner() &&
          request.resource.data.createdAt is timestamp &&
          request.resource.data.updatedAt is timestamp &&
          request.resource.data.messageCount == 0 &&
          request.resource.data.contextType in ['my-records', 'subject', 'all-accessible', 'specific-records'] &&
          request.resource.data.recordCount >= 0 &&
          // Title must be encrypted (placeholder only)
          request.resource.data.title is string;

        // UPDATE: User can update their own chats
        // - Can update encrypted title, context info, message count, preview
        // - Cannot modify createdAt
        // - Must update updatedAt
        allow update: if isOwner() &&
          request.resource.data.createdAt == resource.data.createdAt &&
          request.resource.data.updatedAt is timestamp;

        // DELETE: User can delete their own chats
        allow delete: if isOwner();

        // --- MESSAGES SUBCOLLECTION ---
        match /messages/{messageId} {
          // READ: Only chat owner can read messages
          allow read: if request.auth != null && request.auth.uid == userId;

          // CREATE: Only chat owner can add messages
          // Encrypted content stored directly in message document
          allow create: if request.auth != null &&
            request.auth.uid == userId &&
            request.resource.data.role in ['user', 'assistant'] &&
            request.resource.data.timestamp is timestamp &&
            // Content must be encrypted (placeholder only)
            request.resource.data.content is string;

          // UPDATE: Not allowed - messages are immutable
          allow update: if false;

          // DELETE: Only chat owner can delete messages
          allow delete: if request.auth != null && request.auth.uid == userId;
        }
      }
    }

    // ============================================
    // WRAPPED CHAT KEYS
    // ============================================
    
    match /wrappedChatKeys/{wrappedKeyId} {
      // wrappedKeyId format: {chatId}_{userId}
      
      // Helper: Extract userId from document ID
      function extractUserId() {
        return wrappedKeyId.split('_')[1];
      }

      // READ: Only the key owner can read
      allow read: if request.auth != null &&
        request.auth.uid == extractUserId();

      // CREATE: User can create wrapped keys for their own chats
      // Must match the document ID format and include required fields
      allow create: if request.auth != null &&
        request.auth.uid == extractUserId() &&
        request.resource.data.userId == request.auth.uid &&
        request.resource.data.chatId is string &&
        request.resource.data.wrappedKey is string &&
        request.resource.data.isActive == true &&
        request.resource.data.createdAt is timestamp;

      // UPDATE: User can deactivate their own keys
      allow update: if request.auth != null &&
        request.auth.uid == extractUserId() &&
        resource.data.userId == request.auth.uid &&
        // Only allow toggling isActive
        request.resource.data.diff(resource.data).affectedKeys().hasOnly(['isActive']);

      // DELETE: User can delete their own wrapped keys
      allow delete: if request.auth != null &&
        request.auth.uid == extractUserId() &&
        resource.data.userId == request.auth.uid;
    }
    
    // ============================================
    // RECORDS
    // ============================================

    match /records/{recordId} {
      // READ: User can read if they have any role on the record
      allow read: if request.auth != null && (
        resource.data.uploadedBy == request.auth.uid ||
        request.auth.uid in resource.data.owners ||
        request.auth.uid in resource.data.administrators ||
        request.auth.uid in resource.data.viewers ||
        request.auth.uid in resource.data.subjects
      );

      // CREATE: Must be authenticated and have management structure
      allow create: if request.auth != null && willHaveManagement();
     
      // UPDATE: Multiple flows for different use cases
      // BRANCH 1: Admin/owner updating record
      allow update: if request.auth != null && (
        (
          (request.auth.uid in resource.data.administrators ||
           request.auth.uid in resource.data.owners) &&
          willHaveManagement() &&
          request.resource.data.get('subjects', []) == resource.data.get('subjects', []) &&
          (!isModifyingOwners() || 
           (resource.data.owners.size() == 0 && request.auth.uid in resource.data.administrators) ||
           (resource.data.owners.size() > 0 && request.auth.uid in resource.data.owners))
        ) ||
        // BRANCH 2: Subject consent flow - user adding self to subjects
        (
          (request.auth.uid in resource.data.viewers ||
           request.auth.uid in resource.data.administrators ||
           request.auth.uid in resource.data.owners) &&
          isOnlyAddingSelfAsSubject()
        ) ||
        // BRANCH 3: Subject rejection flow - removing self
        (
          request.auth.uid in resource.data.subjects &&
          isSelfRejectionFlow()
        ) ||
        // BRANCH 4: Credibility score update
        (
          (request.auth.uid in resource.data.owners ||
          request.auth.uid in resource.data.administrators ||
          request.auth.uid in resource.data.viewers ||
          request.auth.uid in resource.data.subjects) &&
          request.resource.data.diff(resource.data).affectedKeys().hasOnly(['credibility'])
        )
      );

      // DELETE: Owners only, or admins if no owners exist
      allow delete: if request.auth != null && (
        request.auth.uid in resource.data.owners ||
        (resource.data.owners.size() == 0 && request.auth.uid in resource.data.administrators)
      );
    }
       
    // ============================================
    // RECORD VERSIONS
    // ============================================

    match /recordVersions/{versionId} {
      allow read: if request.auth != null && hasRoleOnRecord(resource.data.recordId);

      allow create: if request.auth != null && 
        isAdminOrOwnerOfRecord(request.resource.data.recordId) &&
        request.resource.data.editedBy == request.auth.uid;

      allow update: if false; // Versions are immutable

      allow delete: if request.auth != null &&     
      exists(/databases/$(database)/documents/records/$(resource.data.recordId)) &&
      isAdminOrOwnerOfRecord(resource.data.recordId);
    }
    
    // ============================================
    // SUBJECT CONSENT REQUESTS
    // ============================================

    match /subjectConsentRequests/{requestId} {
      // READ: User can read if they:
      // 1. Are the target user (receiving the request)
      // 2. Requested it themselves
      // 3. Are an admin/owner of the record
      allow read: if request.auth != null && (
      !exists(/databases/$(database)/documents/subjectConsentRequests/$(requestId)) ||
        resource.data.subjectId == request.auth.uid ||
        resource.data.requestedBy == request.auth.uid ||
        (request.auth.uid in get(/databases/$(database)/documents/records/$(resource.data.recordId)).data.owners ||
         request.auth.uid in get(/databases/$(database)/documents/records/$(resource.data.recordId)).data.administrators)
      );

      // CREATE: Must be authenticated AND:
      // 1. Be an admin/owner of the record
      // 2. Set themselves as requestedBy
      // 3. Include required fields
      // 4. Status must be 'pending'
      allow create: if request.auth != null &&
        isAdminOrOwnerOfRecord(request.resource.data.recordId) &&
        request.resource.data.requestedBy == request.auth.uid &&
        request.resource.data.status == 'pending' &&
        request.resource.data.recordId != null &&
        request.resource.data.subjectId != null &&
        request.resource.data.createdAt is timestamp &&
        (!('grantedAccessOnSubjectRequest' in request.resource.data.keys()) || 
         request.resource.data.grantedAccessOnSubjectRequest is bool);

      // UPDATE: Two branches:
      // 1. Subject can accept/reject
      // 2. Requester can update grantedAccessOnSubjectRequest
      // BRANCH 1: Subject accepting/rejecting
      allow update: if request.auth != null && (
        (
          resource.data.subjectId == request.auth.uid &&
          request.resource.data.status in ['accepted', 'rejected'] &&
          request.resource.data.diff(resource.data).affectedKeys().hasOnly(['status', 'respondedAt', 'rejection']) &&
          (!('respondedAt' in request.resource.data.diff(resource.data).affectedKeys()) || 
           request.resource.data.respondedAt is timestamp)
        ) 
        ||
        // BRANCH 2: Requester updating grantedAccessOnSubjectRequest
        (
          resource.data.requestedBy == request.auth.uid &&
          request.resource.data.diff(resource.data).affectedKeys().hasOnly(['grantedAccessOnSubjectRequest', 'rejection','lastModified'])
        )
      );

      // DELETE: Only the requester or record admins/owners can delete
      allow delete: if request.auth != null && (
        resource.data.requestedBy == request.auth.uid ||
        isAdminOrOwnerOfRecord(resource.data.recordId)
      );
    }

    // ============================================
    // SUBJECT REMOVAL REQUESTS
    // ============================================

    match /subjectRemovalRequests/{requestId} {
      // Helper: Check if target is actually a subject of the record
      function isSubjectOfRecord() {
        let record = get(/databases/$(database)/documents/records/$(request.resource.data.recordId));
        return request.resource.data.subjectId in record.data.subjects;
      }

      // READ: User can read if they:
      // 1. Are the subject (receiving the request)
      // 2. Requested it themselves
      // 3. Are an owner/admin of the record
      allow read: if request.auth != null && (
        !exists(/databases/$(database)/documents/subjectRemovalRequests/$(requestId)) ||
        resource.data.subjectId == request.auth.uid ||
        resource.data.requestedBy == request.auth.uid ||
        request.auth.uid in get(/databases/$(database)/documents/records/$(resource.data.recordId)).data.subjects ||
        isAdminOrOwnerOfRecord(resource.data.recordId)
      );

      // CREATE: Must be authenticated AND:
      // 1. Be an owner (or admin if no owners) of the record
      // 2. Set themselves as requestedBy
      // 3. Cannot request removal of themselves
      // 4. Target must be a current subject
      // 5. Status must be 'pending'
      // 6. Required fields present
      allow create: if request.auth != null &&
        isAdminOrOwnerOfRecord(request.resource.data.recordId) &&
        request.resource.data.requestedBy == request.auth.uid &&
        request.resource.data.subjectId != request.auth.uid &&
        isSubjectOfRecord() &&
        request.resource.data.status == 'pending' &&
        request.resource.data.recordId != null &&
        request.resource.data.subjectId != null &&
        request.resource.data.createdAt is timestamp;

      // UPDATE: Only the subject can accept/reject
      allow update: if request.auth != null &&
        resource.data.subjectId == request.auth.uid &&
        resource.data.status == 'pending' &&
        request.resource.data.status in ['accepted', 'rejected'] &&
        request.resource.data.diff(resource.data).affectedKeys().hasOnly(['status', 'respondedAt', 'subjectResponse']) &&
        request.resource.data.respondedAt is timestamp;

      // DELETE: Requester or record owners/admins can delete (for cancellation)
      allow delete: if request.auth != null && (
        resource.data.requestedBy == request.auth.uid ||
        isAdminOrOwnerOfRecord(resource.data.recordId)
      );
    }
    
    // ============================================
    // VERIFICATIONS
    // ============================================

    match /verifications/{verificationId} {
      
      // READ: Allow if user is verifier OR has role on the associated record
      // Note: For queries by recordId, the get() call happens per-document
      allow read: if request.auth != null && (
        !exists(/databases/$(database)/documents/verifications/$(verificationId)) ||
        // User is the verifier (can always read their own)
        resource.data.verifierId == request.auth.uid ||
        // User has a role on the record this verification belongs to
        hasRoleOnRecord(resource.data.recordId)
      );

      // CREATE: 
      // - User must have a role on the record
      // - User must be the verifier
      // - Document ID must match expected format (enforces uniqueness)
      // - Required fields validated
      allow create: if request.auth != null &&
        hasRoleOnRecord(request.resource.data.recordId) &&
        request.resource.data.verifierId == request.auth.uid &&
        // Enforce document ID format: {recordHash}_{verifierId}
        verificationId == request.resource.data.recordHash + '_' + request.auth.uid &&
        // Validate required fields
        request.resource.data.isActive == true &&
        request.resource.data.level in [1, 2, 3] &&
        request.resource.data.chainStatus == 'pending' &&
        request.resource.data.createdAt is timestamp;

      // Only the original verifier can modify their verification
      allow update: if request.auth != null &&
        resource.data.verifierId == request.auth.uid &&
        // Immutable fields - cannot be changed
        request.resource.data.verifierId == resource.data.verifierId &&
        request.resource.data.recordId == resource.data.recordId &&
        request.resource.data.recordHash == resource.data.recordHash &&
        request.resource.data.createdAt == resource.data.createdAt;

      // DELETE: Not allowed - use isActive flag instead
      allow delete: if false;
    }

    // ============================================
    // DISPUTES
    // ============================================
  
    match /disputes/{disputeId} {
      // READ: Allow if user is disputer OR has role on the associated record
      allow read: if request.auth != null && (
        !exists(/databases/$(database)/documents/disputes/$(disputeId)) ||
        resource.data.disputerId == request.auth.uid ||
        hasRoleOnRecord(resource.data.recordId)
      );

      // CREATE: 
      // - User must have a role on the record
      // - User must be the disputer
      // - Document ID must match expected format (enforces uniqueness)
      // - Required fields validated
      allow create: if request.auth != null &&
        hasRoleOnRecord(request.resource.data.recordId) &&
        request.resource.data.disputerId == request.auth.uid &&
        // Enforce document ID format: {recordHash}_{disputerId}
        disputeId == request.resource.data.recordHash + '_' + request.auth.uid &&
        // Validate required fields
        request.resource.data.isActive == true &&
        request.resource.data.severity in [1, 2, 3] &&
        request.resource.data.culpability in [0, 1, 2, 3, 4, 5] &&
        request.resource.data.chainStatus == 'pending' &&
        request.resource.data.createdAt is timestamp;

      // Only the original disputer can modify their dispute
      allow update: if request.auth != null &&
        resource.data.disputerId == request.auth.uid &&
        // Immutable fields - cannot be changed
        request.resource.data.disputerId == resource.data.disputerId &&
        request.resource.data.recordId == resource.data.recordId &&
        request.resource.data.recordHash == resource.data.recordHash &&
        request.resource.data.createdAt == resource.data.createdAt &&
        // Notes hash is immutable (it's on-chain)
        request.resource.data.notesHash == resource.data.notesHash &&
        request.resource.data.encryptedNotes == resource.data.encryptedNotes;

      // DELETE: Not allowed - use isActive flag instead
      allow delete: if false;
    }

    // ============================================
    // DISPUTE REACTIONS
    // ============================================
  
    match /disputeReactions/{reactionId} {
      // READ: Allow if user is reactor OR has role on the record
      allow read: if request.auth != null && (
        !exists(/databases/$(database)/documents/disputeReactions/$(reactionId)) ||
          resource.data.reactorId == request.auth.uid ||
          hasRoleOnRecord(resource.data.recordId)
      );

      // CREATE: User must be the reactor
      allow create: if request.auth != null &&
        request.resource.data.reactorId == request.auth.uid &&
        request.resource.data.isActive == true &&
        request.resource.data.chainStatus == 'pending' &&
        request.resource.data.createdAt is timestamp;

      // Only the original reactor can modify their reaction
      allow update: if request.auth != null &&
        resource.data.reactorId == request.auth.uid &&
        // Immutable fields
        request.resource.data.reactorId == resource.data.reactorId &&
        request.resource.data.recordHash == resource.data.recordHash &&
        request.resource.data.disputerId == resource.data.disputerId &&
        request.resource.data.createdAt == resource.data.createdAt;

      // DELETE: Not allowed - use isActive flag instead
      allow delete: if false;
    }

    // ============================================
    // SCORE EVENTS (Credibility Audit Trail)
    // ============================================
    
    match /scoreEvents/{eventId} {
      // READ: Allow if user has a role on the associated record
      // This allows users to see the credibility history for records they can access
      allow read: if request.auth != null && (
        !exists(/databases/$(database)/documents/scoreEvents/$(eventId)) ||
        hasRoleOnRecord(resource.data.recordId)
      );

      // CREATE: User must:
      // 1. Have a role on the record
      // 2. Be the one creating the event (createdBy matches auth uid)
      // 3. Document ID must start with recordId (format: recordId_timestamp)
      // 4. Include required fields
      allow create: if request.auth != null &&
        hasRoleOnRecord(request.resource.data.recordId) &&
        request.resource.data.createdBy == request.auth.uid &&
        // Enforce document ID starts with recordId_
        eventId.matches(request.resource.data.recordId + '_[0-9]+') &&
        request.resource.data.recordId != null &&
        request.resource.data.recordHash != null &&
        request.resource.data.eventType in [
          'verification', 
          'verification_revoked', 
          'verification_modified',
          'dispute',
          'dispute_revoked',
          'dispute_modified'
        ] &&
        request.resource.data.scoreDelta is number &&
        request.resource.data.createdAt is timestamp;

      allow update: if false; // Immutable audit trail
      allow delete: if false; // Immutable audit trail
    }

    // ============================================
    // RECORD DELETION EVENTS
    // ============================================

    match /recordDeletionEvents/{recordId} {
      // READ: Only affected users can read (for audit trail)
      allow read: if request.auth != null && (
        resource.data.deletedBy == request.auth.uid ||
        request.auth.uid in resource.data.affectedUsers.owners ||
        request.auth.uid in resource.data.affectedUsers.administrators ||
        request.auth.uid in resource.data.affectedUsers.viewers ||
        request.auth.uid in resource.data.affectedUsers.subjects
      );

      // CREATE: Only owners (or admins if no owners) can create deletion events
      // Must verify they can delete the record BEFORE creating the event
      allow create: if request.auth != null &&
        exists(/databases/$(database)/documents/records/$(recordId)) &&
        (request.auth.uid in get(/databases/$(database)/documents/records/$(recordId)).data.owners ||
        (get(/databases/$(database)/documents/records/$(recordId)).data.owners.size() == 0 && 
          request.auth.uid in get(/databases/$(database)/documents/records/$(recordId)).data.administrators)) &&
        request.resource.data.deletedBy == request.auth.uid &&
        request.resource.data.deletionComplete == false;

      // UPDATE: Only the deleter can mark as complete
      allow update: if request.auth != null &&
        resource.data.deletedBy == request.auth.uid &&
        request.resource.data.diff(resource.data).affectedKeys().hasOnly(['deletionComplete']) &&
        request.resource.data.deletionComplete == true;

      // DELETE: Only server
      allow delete: if isServerWrite();
    }

    // ============================================
    // ENCRYPTION & SECURITY
    // ============================================

    match /userEncryptionKeys/{userId} {
      allow read, write: if request.auth != null && request.auth.uid == userId;
    }

    match /wrappedKeys/{wrappedKeyId} {
      allow read: if request.auth != null;

      allow create: if request.auth != null &&
        isAdminOrOwnerOfRecord(request.resource.data.recordId);

      allow update: if request.auth != null &&
        isAdminOrOwnerOfRecord(resource.data.recordId);

      allow delete: if request.auth != null &&
        exists(/databases/$(database)/documents/records/$(resource.data.recordId)) && 
        isAdminOrOwnerOfRecord(resource.data.recordId);
    }

    // ============================================
    // SYSTEM QUEUES & LOGGING
    // ============================================

    match /pendingPermissions/{permissionHash} {
      allow create: if request.auth != null &&
        request.resource.data.recordId != null &&
        request.resource.data.receiverId != null;

      allow read: if request.auth != null;
      allow update: if request.auth != null;
      allow delete: if request.auth != null;
    }
    
    match /blockchainSyncQueue/{queueId} {
      allow create: if request.auth != null &&
        request.resource.data.userId == request.auth.uid &&
        request.resource.data.status == 'pending' &&
        request.resource.data.retryCount == 0;

      allow read, update: if request.auth != null &&
        (resource.data.userId == request.auth.uid || isServerWrite());

      allow delete: if isServerWrite();
    }

    match /audit/{auditId} {
      allow write: if request.auth != null;
      allow read: if false;
    }
  }
}
